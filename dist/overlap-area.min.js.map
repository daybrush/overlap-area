{"version":3,"file":"overlap-area.min.js","sources":["../src/index.ts"],"sourcesContent":["import { sum, findIndex, getShapeDirection, getDist } from \"@daybrush/utils\";\nimport { PointInfo, Rect } from \"./types\";\n\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\nexport function getAreaSize(points: number[][]): number {\n    if (points.length < 3) {\n        return 0;\n    }\n    return Math.abs(sum(points.map((point, i) => {\n        const nextPoint = points[i + 1] || points[0];\n\n        return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n    }))) / 2;\n}\n\n\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\nexport function fitPoints(points: number[][], rect: Rect): number[][] {\n    const { width, height, left, top } = rect;\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const ratioX = width / (maxX - minX);\n    const ratioY = height / (maxY - minY);\n\n    return points.map(point => {\n        return [\n            left + (point[0] - minX) * ratioX,\n            top + (point[1] - minY) * ratioY,\n        ];\n    });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\nexport function getMinMaxs(points: number[][]): { minX: number, minY: number, maxX: number, maxY: number } {\n    const xs = points.map(point => point[0]);\n    const ys = points.map(point => point[1]);\n\n    return {\n        minX: Math.min(...xs),\n        minY: Math.min(...ys),\n        maxX: Math.max(...xs),\n        maxY: Math.max(...ys),\n    };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\nexport function isInside(pos: number[], points: number[][], excludeLine?: boolean): boolean {\n    const [x, y] = pos;\n    const {\n        minX,\n        minY,\n        maxX,\n        maxY,\n    } = getMinMaxs(points);\n\n    const xLine = [[minX, y], [maxX, y]];\n    const yLine = [[x, minY], [x, maxY]];\n    const xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n    const yLinearConstants = getLinearConstants(yLine[0], yLine[1]);\n    const lines = convertLines(points);\n    const intersectionXPoints: number[][] = [];\n    const intersectionYPoints: number[][] = [];\n\n    lines.forEach(line => {\n        const linearConstants = getLinearConstants(line[0], line[1]);\n        const xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n        const yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);\n\n        if (xPoints.length === 1 ? line[0][1] !== y : true) {\n            intersectionXPoints.push(...xPoints);\n        }\n        if (yPoints.length === 1 ? line[0][0] !== x : true) {\n            intersectionYPoints.push(...yPoints);\n        }\n\n        if (!linearConstants[0]) {\n            intersectionXPoints.push(...xPoints);\n        }\n        if (!linearConstants[1]) {\n            intersectionYPoints.push(...yPoints);\n        }\n    });\n\n    if (!excludeLine) {\n        if (\n            findIndex(intersectionXPoints, p => p[0] === x) > -1\n            || findIndex(intersectionYPoints, p => p[1] === y) > -1\n        ) {\n            return true;\n        }\n    }\n    if (\n        (intersectionXPoints.filter(p => p[0] > x).length % 2)\n        && (intersectionYPoints.filter(p => p[1] > y).length % 2)\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getLinearConstants(point1: number[], point2: number[]): [number, number, number] {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    // ax + by + c = 0\n    // [a, b, c]\n    let a = 0;\n    let b = 0;\n    let c = 0;\n\n    if (x1 === x2 && y1 === y2) {\n        return [0, 0, 0];\n    } if (x1 === x2) {\n        // x = x1\n        return [1, 0, -x1];\n    } else if (y1 === y2) {\n        // y = y1\n        return [0, 1, -y1];\n    } else {\n        // x1 + a * y1 + b = 0\n        // x2 + a * y2 + b = 0\n        // (x1 -x2) + (y1 - y2) * a = 0\n        // a = (x2 - x1) / (y1 - y2)\n        // x1 + (x2 - x1) / (y1 - y2)\n\n        const a = (x2 - x1) / (y1 - y2);\n        const b = -x1 - a * y1;\n        return [1, a, b];\n    }\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\nexport function getIntersectionPointsByConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n): number[][] {\n    const [a1, b1, c1] = linearConstants1;\n    const [a2, b2, c2] = linearConstants2;\n\n    const isZeroA = a1 === 0 && a2 === 0;\n    const isZeroB = b1 === 0 && b2 === 0;\n    if (isZeroA && isZeroB) {\n        return [];\n    } else if (isZeroA) {\n        // b1 * y + c1 = 0\n        // b2 * y + c2 = 0\n        const y1 = -c1 / b1;\n        const y2 = -c2 / b2;\n\n        if (y1 !== y2) {\n            return [];\n        } else {\n            return [\n                [-Infinity, y1],\n                [Infinity, y1],\n            ];\n        }\n    } else if (isZeroB) {\n        // a1 * x + c1 = 0\n        // a2 * x + c2 = 0\n        const x1 = -c1 / a1;\n        const x2 = -c2 / a2;\n\n        if (x1 !== x2) {\n            return [];\n        } else {\n            return [\n                [x1, -Infinity],\n                [x1, Infinity],\n            ];\n        }\n    } else if (a1 === 0) {\n        // b1 * y + c1 = 0\n        // y = - c1 / b1;\n        // a2 * x + b2 * y + c2 = 0\n        const y = -c1 / b1;\n        const x = -(b2 * y + c2) / a2;\n\n        return [[x, y]];\n    } else if (a2 === 0) {\n        // b2 * y + c2 = 0\n        // y = - c2 / b2;\n        // a1 * x + b1 * y + c1 = 0\n        const y = -c2 / b2;\n        const x = -(b1 * y + c1) / a1;\n\n        return [[x, y]];\n    } else if (b1 === 0) {\n        // a1 * x + c1 = 0\n        // x = - c1 / a1;\n        // a2 * x + b2 * y + c2 = 0\n        const x = - c1 / a1;\n        const y = -(a2 * x + c2) / b2;\n\n        return [[x, y]];\n    } else if (b2 === 0) {\n        // a2 * x + c2 = 0\n        // x = - c2 / a2;\n        // a1 * x + b1 * y + c1 = 0\n        const x = - c2 / a2;\n        const y = -(a1 * x + c1) / b1;\n\n        return [[x, y]];\n    } else {\n        // a1 * x + b1 * y + c1 = 0\n        // a2 * x + b2 * y + c2 = 0\n        // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n        // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n        // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n        const x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n        const y = -(a1 * x + c1) / b1;\n\n        return [[x, y]];\n    }\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\nexport function getIntersectionPoints(\n    line1: number[][],\n    line2: number[][],\n    isLimit?: boolean,\n): number[][] {\n    const points = getIntersectionPointsByConstants(\n        getLinearConstants(line1[0], line1[1]),\n        getLinearConstants(line2[0], line2[1]),\n    );\n\n    if (isLimit) {\n        return getPointsOnLines(points, [line1, line2]);\n    }\n    return points;\n}\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\nexport function getPointsOnLines(\n    points: number[][],\n    lines: number[][][],\n): number[][] {\n    const minMaxs = lines.map(line => [0, 1].map(order => [\n        Math.min(line[0][order], line[1][order]),\n        Math.max(line[0][order], line[1][order]),\n    ]));\n    if (points.length === 2) {\n        const [x, y] = points[0];\n        if (x === points[1][0]) {\n            /// Math.max(minY1, minY2)\n            const top = Math.max(...minMaxs.map(minMax => minMax[1][0]));\n            /// Math.min(maxY1, miax2)\n            const bottom = Math.min(...minMaxs.map(minMax => minMax[1][1]));\n\n            if (top > bottom) {\n                return [];\n            }\n            return [\n                [x, top],\n                [x, bottom],\n            ];\n        } else if (y === points[1][1]) {\n            /// Math.max(minY1, minY2)\n            const left = Math.max(...minMaxs.map(minMax => minMax[0][0]));\n            /// Math.min(maxY1, miax2)\n            const right = Math.min(...minMaxs.map(minMax => minMax[0][1]));\n\n            if (left > right) {\n                return [];\n            }\n            return [\n                [left, y],\n                [right, y],\n            ];\n        }\n    }\n\n    return points.filter(point => {\n        return minMaxs.every(minMax => {\n            return (minMax[0][0] <= point[0] && point[0] <= minMax[0][1])\n                && (minMax[1][0] <= point[1] && point[1] <= minMax[1][1]);\n        });\n    });\n\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\nexport function convertLines(points: number[][]): number[][][] {\n    return [...points.slice(1), points[0]].map((point, i) => [points[i], point]);\n}\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapPoints(points1: number[][], points2: number[][]): number[][] {\n    const targetPoints1 = points1.slice();\n    const targetPoints2 = points2.slice();\n\n    if (getShapeDirection(targetPoints1) === -1) {\n        targetPoints1.reverse();\n    }\n    if (getShapeDirection(targetPoints2) === -1) {\n        targetPoints2.reverse();\n    }\n    const lines1 = convertLines(targetPoints1);\n    const lines2 = convertLines(targetPoints2);\n    const linearConstantss1 = lines1.map(line1 => getLinearConstants(line1[0], line1[1]));\n    const linearConstantss2 = lines2.map(line2 => getLinearConstants(line2[0], line2[1]));\n\n    const overlapInfos: Array<{\n        index1: number;\n        index2: number;\n        pos: number[];\n    }> = [];\n\n    linearConstantss1.forEach((linearConstants1, i) => {\n        const line1 = lines1[i];\n        const linePointInfos: PointInfo[] = [];\n        linearConstantss2.forEach((linearConstants2, j) => {\n            const intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n            const points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n\n            linePointInfos.push(...points.map(pos => ({\n                index1: i,\n                index2: j,\n                pos,\n            })));\n        });\n        linePointInfos.sort((a, b) => {\n            return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n        });\n\n        overlapInfos.push(...linePointInfos);\n\n        if (isInside(line1[1], targetPoints2)) {\n            overlapInfos.push({\n                index1: i,\n                index2: -1,\n                pos: line1[1],\n            });\n        }\n    });\n\n    lines2.forEach((line2, i) => {\n        if (isInside(line2[1], targetPoints1)) {\n            let isNext = false;\n            let index = findIndex(overlapInfos, ({ index2 }) => {\n                if (index2 === i) {\n                    isNext = true;\n                    return false;\n                }\n\n                if (isNext) {\n                    return true;\n                }\n                return false;\n            });\n            if (index === -1) {\n                isNext = false;\n                index = findIndex(overlapInfos, ({ index1, index2 }) => {\n                    if (index1 === -1 && index2 + 1 === i) {\n                        isNext = true;\n                        return false;\n                    }\n\n                    if (isNext) {\n                        return true;\n                    }\n                    return false;\n                });\n            }\n            if (index === -1) {\n                overlapInfos.push({\n                    index1: -1,\n                    index2: i,\n                    pos: line2[1],\n                });\n            } else {\n                overlapInfos.splice(index, 0, {\n                    index1: -1,\n                    index2: i,\n                    pos: line2[1],\n                });\n            }\n        }\n    });\n    // console.log(overlapInfos);\n    const overlapPoints = overlapInfos.map(({ pos }) => pos);\n    const pointMap: Record<string, boolean> = {};\n\n    return overlapPoints.filter(point => {\n        const key = `${point[0]}x${point[1]}`;\n\n        if (pointMap[key]) {\n            return false;\n        }\n        pointMap[key] = true;\n        return true;\n    });\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapSize(points1: number[][], points2: number[][]): number {\n    const points = getOverlapPoints(points1, points2);\n\n    return getAreaSize(points);\n}\n"],"names":["getAreaSize","points","length","Math","abs","sum","map","point","i","nextPoint","getMinMaxs","xs","ys","minX","min","minY","maxX","max","maxY","isInside","pos","excludeLine","x","y","_a","xLine","yLine","xLinearConstants","getLinearConstants","yLinearConstants","lines","convertLines","intersectionXPoints","intersectionYPoints","forEach","line","linearConstants","xPoints","getPointsOnLines","getIntersectionPointsByConstants","yPoints","push","findIndex","p","filter","point1","point2","x1","y1","x2","y2","a_1","linearConstants1","linearConstants2","a1","b1","c1","a2","b2","c2","isZeroA","isZeroB","Infinity","minMaxs","order","top","minMax","bottom","left","right","every","__spreadArrays","slice","getOverlapPoints","points1","points2","targetPoints1","targetPoints2","getShapeDirection","reverse","lines1","lines2","linearConstantss1","line1","linearConstantss2","line2","overlapInfos","linePointInfos","j","index1","index2","sort","a","b","getDist","isNext_1","index","splice","overlapPoints","pointMap","key","rect","width","height","ratioX","ratioY","isLimit"],"mappings":"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"}