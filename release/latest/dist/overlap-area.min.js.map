{"version":3,"file":"overlap-area.min.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import { throttle, TINY_NUM } from \"@daybrush/utils\";\n\nexport function tinyThrottle(num: number) {\n    return throttle(num, TINY_NUM);\n}\n\nexport function isSameConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n) {\n    return linearConstants1.every((v, i) => tinyThrottle(v - linearConstants2[i]) === 0);\n}\n\nexport function isSamePoint(\n    point1: number[],\n    point2: number[],\n) {\n    return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);\n}\n\nexport function flat<Type extends any>(arr: Type[][]): Type[] {\n    return arr.reduce<Type[]>((prev, current) => {\n        prev.push(...current);\n        return prev;\n    }, []);\n}\n","import { sum, findIndex, getShapeDirection, getDist, throttle, TINY_NUM, find } from \"@daybrush/utils\";\nimport { OverlapPointInfo, PointInfo, Rect } from \"./types\";\nimport { flat, isSameConstants, isSamePoint, tinyThrottle } from \"./utils\";\n\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\nexport function getAreaSize(points: number[][]): number {\n    if (points.length < 3) {\n        return 0;\n    }\n    return Math.abs(sum(points.map((point, i) => {\n        const nextPoint = points[i + 1] || points[0];\n\n        return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n    }))) / 2;\n}\n\n\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\nexport function fitPoints(points: number[][], rect: Rect): number[][] {\n    const { width, height, left, top } = rect;\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const ratioX = width / (maxX - minX);\n    const ratioY = height / (maxY - minY);\n\n    return points.map(point => {\n        return [\n            left + (point[0] - minX) * ratioX,\n            top + (point[1] - minY) * ratioY,\n        ];\n    });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\nexport function getMinMaxs(points: number[][]): { minX: number, minY: number, maxX: number, maxY: number } {\n    const xs = points.map(point => point[0]);\n    const ys = points.map(point => point[1]);\n\n    return {\n        minX: Math.min(...xs),\n        minY: Math.min(...ys),\n        maxX: Math.max(...xs),\n        maxY: Math.max(...ys),\n    };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\nexport function isInside(pos: number[], points: number[][], excludeLine?: boolean): boolean {\n    const [x, y] = pos;\n    const {\n        minX,\n        maxX,\n    } = getMinMaxs(points);\n\n    const xLine = [[minX, y], [maxX, y]];\n    const xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n    const lines = convertLines(points);\n\n    interface IntersectionPosInfo {\n        pos: number[];\n        line: number[][];\n        type: \"intersection\" | \"point\" | \"line\";\n    }\n    const intersectionPosInfos: IntersectionPosInfo[] = [];\n\n    lines.forEach(line => {\n        const linearConstants = getLinearConstants(line[0], line[1]);\n        const standardPoint = line[0];\n\n        if (isSameConstants(xLinearConstants, linearConstants)) {\n            intersectionPosInfos.push({\n                pos: pos,\n                line,\n                type: \"line\",\n            });\n        } else {\n            const xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n\n            xPoints.forEach(point => {\n                if (line.some(linePoint => isSamePoint(linePoint, point))) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line,\n                        type: \"point\",\n                    });\n                } else if (tinyThrottle(standardPoint[1] - y) !== 0) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line,\n                        type: \"intersection\",\n                    });\n                }\n            })\n        }\n    });\n\n    if (!excludeLine) {\n        // on line\n        if (find(intersectionPosInfos, p => p[0] === x)) {\n            return true;\n        }\n    }\n    let intersectionCount = 0;\n    const xMap = {};\n\n    intersectionPosInfos.forEach(({ pos, type, line }) => {\n        if (pos[0] > x) {\n            return;\n        }\n        if (type === \"intersection\") {\n            ++intersectionCount;\n        } else if (type === \"line\") {\n            return;\n        } else if (type === \"point\") {\n            const point = find(line, linePoint => linePoint[1] !== y);\n            const prevValue = xMap[pos[0]];\n            const nextValue = point[1] > y ? 1 : -1;\n\n            if (!prevValue) {\n                xMap[pos[0]] = nextValue;\n            } else if (prevValue !== nextValue) {\n                ++intersectionCount;\n            }\n        }\n    });\n    return intersectionCount % 2 === 1;\n}\n/**\n * Get distance from point to constants. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getDistanceFromPointToConstants(\n    [a, b, c]: [number, number, number],\n    pos: number[],\n) {\n    return (a * pos[0] + b * pos[1] + c) / (a * a + b * b);\n}\n\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getLinearConstants(point1: number[], point2: number[]): [number, number, number] {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    // ax + by + c = 0\n    // [a, b, c]\n    let dx = x2 - x1;\n    let dy = y2 - y1;\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n\n    // b > 0\n    // ax + by + c = 0\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    if (!dx) {\n        if (dy) {\n            // -x + 1 = 0\n            a = -1;\n            c = x1;\n        }\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -y1;\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = -a * x1 - y1;\n    }\n\n    return [a, b, c] as [number, number, number];\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\nexport function getIntersectionPointsByConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n): number[][] {\n    const [a1, b1, c1] = linearConstants1;\n    const [a2, b2, c2] = linearConstants2;\n\n    const isZeroA = a1 === 0 && a2 === 0;\n    const isZeroB = b1 === 0 && b2 === 0;\n    let results: number[][] = [];\n\n    if (isZeroA && isZeroB) {\n        return [];\n    } else if (isZeroA) {\n        // b1 * y + c1 = 0\n        // b2 * y + c2 = 0\n        const y1 = -c1 / b1;\n        const y2 = -c2 / b2;\n\n        if (y1 !== y2) {\n            return [];\n        } else {\n            return [\n                [-Infinity, y1],\n                [Infinity, y1],\n            ];\n        }\n    } else if (isZeroB) {\n        // a1 * x + c1 = 0\n        // a2 * x + c2 = 0\n        const x1 = -c1 / a1;\n        const x2 = -c2 / a2;\n\n        if (x1 !== x2) {\n            return [];\n        } else {\n            return [\n                [x1, -Infinity],\n                [x1, Infinity],\n            ];\n        }\n    } else if (a1 === 0) {\n        // b1 * y + c1 = 0\n        // y = - c1 / b1;\n        // a2 * x + b2 * y + c2 = 0\n        const y = -c1 / b1;\n        const x = -(b2 * y + c2) / a2;\n\n        results = [[x, y]];\n    } else if (a2 === 0) {\n        // b2 * y + c2 = 0\n        // y = - c2 / b2;\n        // a1 * x + b1 * y + c1 = 0\n        const y = -c2 / b2;\n        const x = -(b1 * y + c1) / a1;\n\n        results = [[x, y]];\n    } else if (b1 === 0) {\n        // a1 * x + c1 = 0\n        // x = - c1 / a1;\n        // a2 * x + b2 * y + c2 = 0\n        const x = - c1 / a1;\n        const y = -(a2 * x + c2) / b2;\n\n        results = [[x, y]];\n    } else if (b2 === 0) {\n        // a2 * x + c2 = 0\n        // x = - c2 / a2;\n        // a1 * x + b1 * y + c1 = 0\n        const x = - c2 / a2;\n        const y = -(a1 * x + c1) / b1;\n\n        results = [[x, y]];\n    } else {\n        // a1 * x + b1 * y + c1 = 0\n        // a2 * x + b2 * y + c2 = 0\n        // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n        // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n        // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n        const x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n        const y = -(a1 * x + c1) / b1;\n\n        results = [[x, y]];\n    }\n\n    return results.map(result => [result[0], result[1]]);\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\nexport function getIntersectionPoints(\n    line1: number[][],\n    line2: number[][],\n    isLimit?: boolean,\n): number[][] {\n    const points = getIntersectionPointsByConstants(\n        getLinearConstants(line1[0], line1[1]),\n        getLinearConstants(line2[0], line2[1]),\n    );\n\n    if (isLimit) {\n        return getPointsOnLines(points, [line1, line2]);\n    }\n    return points;\n}\n\nexport function isPointOnLine(\n    pos: number[],\n    line: number[][],\n) {\n    const linearConstants = getLinearConstants(line[0], line[1]);\n\n    return tinyThrottle(getDistanceFromPointToConstants(linearConstants, pos)) === 0;\n}\n\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\nexport function getPointsOnLines(\n    points: number[][],\n    lines: number[][][],\n): number[][] {\n    const minMaxs = lines.map(line => [0, 1].map(order => [\n        Math.min(line[0][order], line[1][order]),\n        Math.max(line[0][order], line[1][order]),\n    ]));\n    let results: number[][] = [];\n\n    if (points.length === 2) {\n        const [x, y] = points[0];\n        if (!tinyThrottle(x - points[1][0])) {\n            /// Math.max(minY1, minY2)\n            const top = Math.max(...minMaxs.map(minMax => minMax[1][0]));\n            /// Math.min(maxY1, miax2)\n            const bottom = Math.min(...minMaxs.map(minMax => minMax[1][1]));\n\n            if (tinyThrottle(top - bottom) > 0) {\n                return [];\n            }\n            results = [\n                [x, top],\n                [x, bottom],\n            ];\n        } else if (!tinyThrottle(y - points[1][1])) {\n            /// Math.max(minY1, minY2)\n            const left = Math.max(...minMaxs.map(minMax => minMax[0][0]));\n            /// Math.min(maxY1, miax2)\n            const right = Math.min(...minMaxs.map(minMax => minMax[0][1]));\n\n            if (tinyThrottle(left - right) > 0) {\n                return [];\n            }\n            results = [\n                [left, y],\n                [right, y],\n            ];\n        }\n    }\n\n    if (!results.length) {\n        results = points.filter(point => {\n            const [pointX, pointY] = point;\n\n            return minMaxs.every(minMax => {\n                return (0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX))\n                && (0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY));\n            });\n        });\n    }\n\n    return results.map(result => [tinyThrottle(result[0]), tinyThrottle(result[1])]);\n\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\nexport function convertLines(points: number[][]): number[][][] {\n    return [...points.slice(1), points[0]].map((point, i) => [points[i], point]);\n}\n\nfunction getOverlapPointInfos(points1: number[][], points2: number[][]): OverlapPointInfo[] {\n    const targetPoints1 = points1.slice();\n    const targetPoints2 = points2.slice();\n\n    if (getShapeDirection(targetPoints1) === -1) {\n        targetPoints1.reverse();\n    }\n    if (getShapeDirection(targetPoints2) === -1) {\n        targetPoints2.reverse();\n    }\n    const lines1 = convertLines(targetPoints1);\n    const lines2 = convertLines(targetPoints2);\n    const linearConstantsList1 = lines1.map(line1 => getLinearConstants(line1[0], line1[1]));\n    const linearConstantsList2 = lines2.map(line2 => getLinearConstants(line2[0], line2[1]));\n\n    const overlapInfos: OverlapPointInfo[] = [];\n\n    linearConstantsList1.forEach((linearConstants1, i) => {\n        const line1 = lines1[i];\n        const linePointInfos: OverlapPointInfo[] = [];\n        linearConstantsList2.forEach((linearConstants2, j) => {\n            const intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n            const points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n\n            linePointInfos.push(...points.map(pos => ({\n                index1: i,\n                index2: j,\n                pos,\n                type: \"intersection\" as const,\n            })));\n        });\n        linePointInfos.sort((a, b) => {\n            return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n        });\n\n        overlapInfos.push(...linePointInfos);\n\n        if (isInside(line1[1], targetPoints2)) {\n            overlapInfos.push({\n                index1: i,\n                index2: -1,\n                pos: line1[1],\n                type: \"inside\" as const,\n            });\n        }\n    });\n\n    lines2.forEach((line2, i) => {\n        if (!isInside(line2[1], targetPoints1)) {\n            return;\n        }\n        let isNext = false;\n        let index = findIndex(overlapInfos, ({ index2 }) => {\n            if (index2 === i) {\n                isNext = true;\n                return false;\n            }\n\n            if (isNext) {\n                return true;\n            }\n            return false;\n        });\n        if (index === -1) {\n            isNext = false;\n            index = findIndex(overlapInfos, ({ index1, index2 }) => {\n                if (index1 === -1 && index2 + 1 === i) {\n                    isNext = true;\n                    return false;\n                }\n\n                if (isNext) {\n                    return true;\n                }\n                return false;\n            });\n        }\n        if (index === -1) {\n            overlapInfos.push({\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\" as const,\n            });\n        } else {\n            overlapInfos.splice(index, 0, {\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\" as const,\n            });\n\n        }\n    });\n    const pointMap: Record<string, boolean> = {};\n\n    return overlapInfos.filter(({ pos }) => {\n        const key = `${pos[0]}x${pos[1]}`;\n\n        if (pointMap[key]) {\n            return false;\n        }\n        pointMap[key] = true;\n        return true;\n    });\n}\n\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapPoints(points1: number[][], points2: number[][]): number[][] {\n    const infos = getOverlapPointInfos(points1, points2);\n\n    return infos.map(({ pos }) => pos);\n}\n\nfunction isConnectedLine(line: OverlapPointInfo[]) {\n    const {\n        0: {\n            index1: prevIndex1,\n            index2: prevIndex2,\n        },\n        1: {\n            index1: nextIndex1,\n            index2: nextIndex2,\n        }\n    } = line;\n\n    if (prevIndex1 !== -1) {\n        // same line\n        if (prevIndex1 === nextIndex1) {\n            return true;\n        }\n        if (prevIndex1 + 1 === nextIndex1) {\n            return true;\n        }\n    }\n    if (prevIndex2 !== -1) {\n        // same line\n        if (prevIndex2 === nextIndex2) {\n            return true;\n        }\n        if (prevIndex2 + 1 === nextIndex2) {\n            return true;\n        }\n    }\n\n    return false;\n\n}\n/**\n* Get the areas of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapAreas(points1: number[][], points2: number[][]): number[][][] {\n    const infos = getOverlapPointInfos(points1, points2);\n    const areas: OverlapPointInfo[][] = [];\n    let area: OverlapPointInfo[];\n\n    getOverlapPointInfos(points1, points2).forEach((info, i, arr) => {\n        if (i === 0 || !isConnectedLine([arr[i - 1], info])) {\n            area = [info];\n            areas.push(area);\n        } else {\n            area.push(info);\n        }\n    });\n\n    return areas.map(area => area.map(({ pos }) => pos));\n}\nfunction findReversedAreas(points1: number[][], points2: number[][], index: number = 0, areas: number[][][] = []): number[][][] {\n    const isFirst = areas.length === 0;\n    const length = points1.length;\n    const nextIndex = points1[index] ? index : 0;\n    const nextPoints1 = [...points1.slice(nextIndex), ...points1.slice(0, nextIndex)];\n\n    for (let i = 0; i < length; ++i) {\n        const point1 = nextPoints1[i];\n\n        if (find(points2, point2 => point2[0] === point1[0] && point2[1] === point1[1])) {\n            continue;\n        }\n        if (areas.some(nextArea => find(nextArea, areaPoint => areaPoint[0] === point1[0] && areaPoint[1] === point1[1]))) {\n            if (isFirst) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        let nextArea: number[][];\n\n        if (isFirst) {\n            nextArea = [];\n            areas.push(nextArea);\n        } else {\n            nextArea = areas[areas.length - 1];\n        }\n        nextArea.push(point1);\n\n\n        const line = [point1, points1[index + 1] || points1[0]];\n        const nextPoint2 = points2.filter(point2 => {\n            return isPointOnLine(point2, line);\n        }).sort((a, b) => {\n            return getDist(point1, a) - getDist(point1, b);\n        })[0];\n\n        if (!nextPoint2) {\n            findReversedAreas(nextPoints1, points2, i + 1, areas);\n            break;\n        } else {\n            const point2Index = points2.indexOf(nextPoint2);\n\n            findReversedAreas(points2, points1, point2Index, areas);\n            if (!isFirst) {\n                break;\n            }\n        }\n    }\n    return areas;\n}\nexport function findConnectedAreas(points1: number[][], points2: number[][]) {\n    return findReversedAreas(points1, [...points2].reverse());\n}\n/**\n* Get non-overlapping areas of two shapes based on points1.\n* @memberof OverlapArea\n*/\nexport function getUnoverlapAreas(points1: number[][], points2: number[][]): number[][][] {\n    if (!points2.length) {\n        return [[...points1]];\n    }\n    const overlapAreas = getOverlapAreas(points1, points2);\n     let unoverlapAreas = [points1];\n\n    overlapAreas.forEach(overlapArea => {\n        const nextOverlapArea = [...overlapArea].reverse();\n\n        unoverlapAreas = flat(unoverlapAreas.map(area => {\n            const connectedAreas = findReversedAreas(area, nextOverlapArea);\n            const firstConnectedArea = connectedAreas[0];\n\n            if (connectedAreas.length === 1 && nextOverlapArea.every(point => firstConnectedArea.indexOf(point) === -1)) {\n                const lastPoint = firstConnectedArea[firstConnectedArea.length - 1];\n                const firstPoint = [...nextOverlapArea].sort((a, b) => {\n                    return getDist(lastPoint, a) - getDist(lastPoint, b);\n                })[0];\n                const firstIndex = nextOverlapArea.indexOf(firstPoint);\n\n                firstConnectedArea.push(\n                    ...nextOverlapArea.slice(firstIndex),\n                    ...nextOverlapArea.slice(0, firstIndex),\n                    nextOverlapArea[firstIndex],\n                    lastPoint,\n                );\n            }\n            return connectedAreas;\n        }));\n    });\n\n    return unoverlapAreas;\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapSize(points1: number[][], points2: number[][]): number {\n    const points = getOverlapPoints(points1, points2);\n\n    return getAreaSize(points);\n}\n"],"names":["tinyThrottle","num","TINY_NUM","getAreaSize","points","length","Math","abs","map","point","i","nextPoint","getMinMaxs","xs","ys","minX","min","minY","maxX","max","maxY","isInside","pos","excludeLine","intersectionCount","xMap","x","y","_a","xLine","xLinearConstants","getLinearConstants","lines","convertLines","intersectionPosInfos","forEach","line","linearConstants2","linearConstants","standardPoint","every","v","push","type","getPointsOnLines","getIntersectionPointsByConstants","some","linePoint","point2","point1","find","p","prevValue","nextValue","getDistanceFromPointToConstants","a","b","c","x1","y1","dx","dy","linearConstants1","a1","b1","c1","a2","b2","c2","isZeroA","isZeroB","Infinity","result","isPointOnLine","minMaxs","order","results","left","minMax","right","top","bottom","filter","pointX","pointY","__spreadArray","slice","getOverlapPointInfos","points1","points2","targetPoints1","targetPoints2","lines1","getShapeDirection","reverse","lines2","linearConstantsList1","line1","linearConstantsList2","line2","overlapInfos","pointMap","linePointInfos","j","index1","index2","sort","getDist","isNext","index","findIndex","splice","key","getOverlapPoints","getOverlapAreas","area","areas","info","arr","prevIndex1","prevIndex2","nextIndex1","nextIndex2","findReversedAreas","isFirst","nextIndex","nextPoints1","point2Index","nextArea","areaPoint","nextPoint2","indexOf","rect","width","height","ratioX","ratioY","isLimit","unoverlapAreas","overlapAreas","overlapArea","nextOverlapArea","lastPoint_1","firstIndex","connectedAreas","firstConnectedArea","firstPoint","reduce","prev","current"],"mappings":"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"}