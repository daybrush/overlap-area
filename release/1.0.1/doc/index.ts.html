<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.ts - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/daybrush.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="description" content="index.ts - Documentation"/>

</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h2 class="custom"><a href="https://github.com/daybrush/overlap-area" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><div class="search"><div class="input-area"><input type="text"/></div><button></button></div><ul class="namespaces"><li file="overlaparea" class="parent"><a href="OverlapArea.html">OverlapArea</a><h4><a href="OverlapArea.html#static methods">Static Methods</a></h4><ul class='static methods'><li data-type='method'><a href="OverlapArea.html#.convertLines">convertLines</a></li><li data-type='method'><a href="OverlapArea.html#.fitPoints">fitPoints</a></li><li data-type='method'><a href="OverlapArea.html#.getAreaSize">getAreaSize</a></li><li data-type='method'><a href="OverlapArea.html#.getIntersectionPoints">getIntersectionPoints</a></li><li data-type='method'><a href="OverlapArea.html#.getIntersectionPointsByConstants">getIntersectionPointsByConstants</a></li><li data-type='method'><a href="OverlapArea.html#.getLinearConstants">getLinearConstants</a></li><li data-type='method'><a href="OverlapArea.html#.getMinMaxs">getMinMaxs</a></li><li data-type='method'><a href="OverlapArea.html#.getOverlapPoints">getOverlapPoints</a></li><li data-type='method'><a href="OverlapArea.html#.getOverlapSize">getOverlapSize</a></li><li data-type='method'><a href="OverlapArea.html#.getPointsOnLines">getPointsOnLines</a></li><li data-type='method'><a href="OverlapArea.html#.isInside">isInside</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { sum, findIndex, getShapeDirection, getDist, throttle, TINY_NUM } from "@daybrush/utils";
import { PointInfo, Rect } from "./types";
import { tinyThrottle } from "./utils";

/**
 * @namespace OverlapArea
 */

/**
 * Gets the size of a shape (polygon) made of points.
 * @memberof OverlapArea
 */
export function getAreaSize(points: number[][]): number {
    if (points.length &lt; 3) {
        return 0;
    }
    return Math.abs(sum(points.map((point, i) => {
        const nextPoint = points[i + 1] || points[0];

        return point[0] * nextPoint[1] - nextPoint[0] * point[1];
    }))) / 2;
}


/**
 * Get points that fit the rect,
 * @memberof OverlapArea
 */
export function fitPoints(points: number[][], rect: Rect): number[][] {
    const { width, height, left, top } = rect;
    const { minX, minY, maxX, maxY } = getMinMaxs(points);
    const ratioX = width / (maxX - minX);
    const ratioY = height / (maxY - minY);

    return points.map(point => {
        return [
            left + (point[0] - minX) * ratioX,
            top + (point[1] - minY) * ratioY,
        ];
    });
}
/**
 * Get the minimum and maximum points of the points.
 * @memberof OverlapArea
 */
export function getMinMaxs(points: number[][]): { minX: number, minY: number, maxX: number, maxY: number } {
    const xs = points.map(point => point[0]);
    const ys = points.map(point => point[1]);

    return {
        minX: Math.min(...xs),
        minY: Math.min(...ys),
        maxX: Math.max(...xs),
        maxY: Math.max(...ys),
    };
}
/**
 * Whether the point is in shape
 * @param - point pos
 * @param - shape points
 * @param - whether to check except line
 * @memberof OverlapArea
 */
export function isInside(pos: number[], points: number[][], excludeLine?: boolean): boolean {
    const [x, y] = pos;
    const {
        minX,
        minY,
        maxX,
        maxY,
    } = getMinMaxs(points);

    const xLine = [[minX, y], [maxX, y]];
    const yLine = [[x, minY], [x, maxY]];
    const xLinearConstants = getLinearConstants(xLine[0], xLine[1]);
    const yLinearConstants = getLinearConstants(yLine[0], yLine[1]);
    const lines = convertLines(points);
    const intersectionXPoints: number[][] = [];
    const intersectionYPoints: number[][] = [];

    lines.forEach(line => {
        const linearConstants = getLinearConstants(line[0], line[1]);
        const xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);
        const yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);

        if (xPoints.length === 1 ? line[0][1] !== y : true) {
            intersectionXPoints.push(...xPoints);
        }
        if (yPoints.length === 1 ? line[0][0] !== x : true) {
            intersectionYPoints.push(...yPoints);
        }

        if (!linearConstants[0]) {
            intersectionXPoints.push(...xPoints);
        }
        if (!linearConstants[1]) {
            intersectionYPoints.push(...yPoints);
        }
    });

    if (!excludeLine) {
        if (
            findIndex(intersectionXPoints, p => p[0] === x) > -1
            || findIndex(intersectionYPoints, p => p[1] === y) > -1
        ) {
            return true;
        }
    }
    if (
        (intersectionXPoints.filter(p => p[0] > x).length % 2)
        &amp;&amp; (intersectionYPoints.filter(p => p[1] > y).length % 2)
    ) {
        return true;
    }
    return false;
}

/**
 * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)
 * @return [a, b, c]
 * @memberof OverlapArea
 */
export function getLinearConstants(point1: number[], point2: number[]): [number, number, number] {
    const [x1, y1] = point1;
    const [x2, y2] = point2;
    // ax + by + c = 0
    // [a, b, c]
    let a = 0;
    let b = 0;
    let c = 0;

    if (x1 === x2 &amp;&amp; y1 === y2) {
        return [0, 0, 0];
    } if (x1 === x2) {
        // x = x1
        return [1, 0, -x1];
    } else if (y1 === y2) {
        // y = y1
        return [0, 1, -y1];
    } else {
        // x1 + a * y1 + b = 0
        // x2 + a * y2 + b = 0
        // (x1 -x2) + (y1 - y2) * a = 0
        // a = (x2 - x1) / (y1 - y2)
        // x1 + (x2 - x1) / (y1 - y2)

        const a = (x2 - x1) / (y1 - y2);
        const b = -x1 - a * y1;
        return [1, a, b];
    }
}
/**
 * Get intersection points with linear functions.
 * @memberof OverlapArea
 */
export function getIntersectionPointsByConstants(
    linearConstants1: number[],
    linearConstants2: number[],
): number[][] {
    const [a1, b1, c1] = linearConstants1;
    const [a2, b2, c2] = linearConstants2;

    const isZeroA = a1 === 0 &amp;&amp; a2 === 0;
    const isZeroB = b1 === 0 &amp;&amp; b2 === 0;
    let results: number[][] = [];

    if (isZeroA &amp;&amp; isZeroB) {
        return [];
    } else if (isZeroA) {
        // b1 * y + c1 = 0
        // b2 * y + c2 = 0
        const y1 = -c1 / b1;
        const y2 = -c2 / b2;

        if (y1 !== y2) {
            return [];
        } else {
            return [
                [-Infinity, tinyThrottle(y1)],
                [Infinity, tinyThrottle(y1)],
            ];
        }
    } else if (isZeroB) {
        // a1 * x + c1 = 0
        // a2 * x + c2 = 0
        const x1 = -c1 / a1;
        const x2 = -c2 / a2;

        if (x1 !== x2) {
            return [];
        } else {
            return [
                [tinyThrottle(x1), -Infinity],
                [tinyThrottle(x1), Infinity],
            ];
        }
    } else if (a1 === 0) {
        // b1 * y + c1 = 0
        // y = - c1 / b1;
        // a2 * x + b2 * y + c2 = 0
        const y = -c1 / b1;
        const x = -(b2 * y + c2) / a2;

        results = [[x, y]];
    } else if (a2 === 0) {
        // b2 * y + c2 = 0
        // y = - c2 / b2;
        // a1 * x + b1 * y + c1 = 0
        const y = -c2 / b2;
        const x = -(b1 * y + c1) / a1;

        results = [[x, y]];
    } else if (b1 === 0) {
        // a1 * x + c1 = 0
        // x = - c1 / a1;
        // a2 * x + b2 * y + c2 = 0
        const x = - c1 / a1;
        const y = -(a2 * x + c2) / b2;

        results = [[x, y]];
    } else if (b2 === 0) {
        // a2 * x + c2 = 0
        // x = - c2 / a2;
        // a1 * x + b1 * y + c1 = 0
        const x = - c2 / a2;
        const y = -(a1 * x + c1) / b1;

        results = [[x, y]];
    } else {
        // a1 * x + b1 * y + c1 = 0
        // a2 * x + b2 * y + c2 = 0
        // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0
        // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0
        // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)
        const x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);
        const y = -(a1 * x + c1) / b1;

        results = [[x, y]];
    }

    return results.map(result => [tinyThrottle(result[0]), tinyThrottle(result[1])]);
}
/**
 * Get intersection points to the two lines.
 * @memberof OverlapArea
 */
export function getIntersectionPoints(
    line1: number[][],
    line2: number[][],
    isLimit?: boolean,
): number[][] {
    const points = getIntersectionPointsByConstants(
        getLinearConstants(line1[0], line1[1]),
        getLinearConstants(line2[0], line2[1]),
    );

    if (isLimit) {
        return getPointsOnLines(points, [line1, line2]);
    }
    return points;
}
/**
 * Get the points on the lines (between two points).
 * @memberof OverlapArea
 */
export function getPointsOnLines(
    points: number[][],
    lines: number[][][],
): number[][] {
    const minMaxs = lines.map(line => [0, 1].map(order => [
        Math.min(line[0][order], line[1][order]),
        Math.max(line[0][order], line[1][order]),
    ]));
    let results: number[][] = [];

    if (points.length === 2) {
        const [x, y] = points[0];
        if (x === points[1][0]) {
            /// Math.max(minY1, minY2)
            const top = Math.max(...minMaxs.map(minMax => minMax[1][0]));
            /// Math.min(maxY1, miax2)
            const bottom = Math.min(...minMaxs.map(minMax => minMax[1][1]));

            if (tinyThrottle(top - bottom) > 0) {
                return [];
            }
            results = [
                [x, top],
                [x, bottom],
            ];
        } else if (y === points[1][1]) {
            /// Math.max(minY1, minY2)
            const left = Math.max(...minMaxs.map(minMax => minMax[0][0]));
            /// Math.min(maxY1, miax2)
            const right = Math.min(...minMaxs.map(minMax => minMax[0][1]));

            if (tinyThrottle(left - right) > 0) {
                return [];
            }
            results = [
                [left, y],
                [right, y],
            ];
        }
    }

    if (!results.length) {
        results = points.filter(point => {
            return minMaxs.every(minMax => {
                return (minMax[0][0] &lt;= point[0] &amp;&amp; point[0] &lt;= minMax[0][1])
                    &amp;&amp; (minMax[1][0] &lt;= point[1] &amp;&amp; point[1] &lt;= minMax[1][1]);
            });
        });
    }

    return results.map(result => [tinyThrottle(result[0]), tinyThrottle(result[1])]);

}
/**
* Convert two points into lines.
* @function
* @memberof OverlapArea
*/
export function convertLines(points: number[][]): number[][][] {
    return [...points.slice(1), points[0]].map((point, i) => [points[i], point]);
}
/**
* Get the points of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/
export function getOverlapPoints(points1: number[][], points2: number[][]): number[][] {
    const targetPoints1 = points1.slice();
    const targetPoints2 = points2.slice();

    if (getShapeDirection(targetPoints1) === -1) {
        targetPoints1.reverse();
    }
    if (getShapeDirection(targetPoints2) === -1) {
        targetPoints2.reverse();
    }
    const lines1 = convertLines(targetPoints1);
    const lines2 = convertLines(targetPoints2);
    const linearConstantsList1 = lines1.map(line1 => getLinearConstants(line1[0], line1[1]));
    const linearConstantsList2 = lines2.map(line2 => getLinearConstants(line2[0], line2[1]));

    const overlapInfos: Array&lt;{
        index1: number;
        index2: number;
        pos: number[];
    }> = [];

    linearConstantsList1.forEach((linearConstants1, i) => {
        const line1 = lines1[i];
        const linePointInfos: PointInfo[] = [];
        linearConstantsList2.forEach((linearConstants2, j) => {
            const intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);
            const points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);

            linePointInfos.push(...points.map(pos => ({
                index1: i,
                index2: j,
                pos,
            })));
        });
        linePointInfos.sort((a, b) => {
            return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);
        });

        overlapInfos.push(...linePointInfos);

        if (isInside(line1[1], targetPoints2)) {
            overlapInfos.push({
                index1: i,
                index2: -1,
                pos: line1[1],
            });
        }
    });

    lines2.forEach((line2, i) => {
        if (isInside(line2[1], targetPoints1)) {
            let isNext = false;
            let index = findIndex(overlapInfos, ({ index2 }) => {
                if (index2 === i) {
                    isNext = true;
                    return false;
                }

                if (isNext) {
                    return true;
                }
                return false;
            });
            if (index === -1) {
                isNext = false;
                index = findIndex(overlapInfos, ({ index1, index2 }) => {
                    if (index1 === -1 &amp;&amp; index2 + 1 === i) {
                        isNext = true;
                        return false;
                    }

                    if (isNext) {
                        return true;
                    }
                    return false;
                });
            }
            if (index === -1) {
                overlapInfos.push({
                    index1: -1,
                    index2: i,
                    pos: line2[1],
                });
            } else {
                overlapInfos.splice(index, 0, {
                    index1: -1,
                    index2: i,
                    pos: line2[1],
                });
            }
        }
    });
    // console.log(overlapInfos);
    const overlapPoints = overlapInfos.map(({ pos }) => pos);
    const pointMap: Record&lt;string, boolean> = {};

    return overlapPoints.filter(point => {
        const key = `${point[0]}x${point[1]}`;

        if (pointMap[key]) {
            return false;
        }
        pointMap[key] = true;
        return true;
    });
}
/**
* Gets the size of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/
export function getOverlapSize(points1: number[][], points2: number[][]): number {
    const points = getOverlapPoints(points1, points2);

    return getAreaSize(points);
}
</code></pre>
        </article>
    </section>





<style>


nav li[file="index"]:after {
    display: none;
}
nav li[file="index"] h4, nav li[file="index"] ul {
    display: block;
}
</style>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/daybrush/jsdoc">JSDoc 0.3.8</a> on Sat Jun 18 2022 04:19:05 GMT+0900 (대한민국 표준시) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/utils.min.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/custom.js"></script>
</body>
</html>
